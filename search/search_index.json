{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lib-bpmn-engine","text":""},{"location":"#motivation","title":"Motivation","text":"<p>A BPMN engine, meant to be embedded in Go applications with minimum hurdles, and a pleasant developer experience using it. This approach can increase transparency of code/implementation for non-developers.</p> <p>This library is meant to be embedded in your application and should not introduce more runtime-dependencies. Hence, there's no database support built nor planned. Also, the engine is not agnostic to any high availability approaches, like multiple instances or similar.</p> <p>See Getting Started</p> <p>There's an experimental online playground https://nitram509.github.io/lib-bpmn-engine-js/ available, which leverages the great power of cross-compiling to WASM.</p>"},{"location":"#philosophies-around-bpmn","title":"Philosophies around BPMN","text":"<p>The BPMN specification in its core is a set of graphical symbols (rectangles, arrows, etc.) and a standard definition about how to read/interpret them. With this foundation, it's an excellent opportunity to enrich transparency or communication or discussions about implementation details. So BPMN has a great potential to support me as a developer to not write documentation into a wiki but rather expose the business process via well known symbols/graphics.</p> <p>There's a conceptual similarity in usage between BPMN and OpenAPI/Swagger. As developers, on the one hand side we often use OpenAPI/Swagger to document our endpoints, HTTP methods, and purpose of the (HTTP) interface, our services offer. Hence, we enable others to use and integrate them. With BPMN on the other hand it can be conceptual similar, when it comes to share internal behaviour of our services. I see even larger similarity, when it comes to the question: How do I maintain the documentation? Again, on the one hand side with OpenAPI/Swagger, we tend to either use reflection and code generators or we follow the API spec first approach. The later one is addressed by this library in the BPMN context: Business Process spec first approach</p>"},{"location":"#goals-and-development-guidelines-for-the-engine","title":"goals and development guidelines (for the engine)","text":"<p>The lib-bpmn-engine library follows these architectural goals/guidelines</p> <ul> <li>being graceful in reading BPMN files</li> <li>support multiple (named) instances of the engine within the same process</li> <li>support BPMN elements, as guided/requested by the community (means incremental feature development)</li> <li>not being standard compliant (as in tolerating some errors)</li> <li>no linting/validation of BPMN</li> <li>no database support (just (de-)marshalling is planned)</li> <li>no locking/synchronization support (should be implemented by the application itself)</li> <li>no built-in user interface (but export of events, so UI could be use or built)</li> <li>no built-in scheduler/timer (but can be provided)</li> <li>no support for BPMN compensation spec (which I consider bad practice, for the same reason, why roll-back is more complicated than roll-forward-with-fix)</li> </ul>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>in-memory BPMN engine, to be embedded in other Go applications</li> <li>able to execute BPMN 2.0 xml workflow models</li> <li>no database support by design - there's just marshalling/unmarshalling support planned</li> <li>generic event export interface to make internal processing transparent</li> <li>basic BPMN element supported, see Supported Elements</li> <li>support dynamic decision via FEEL language support</li> </ul> <p>The following experimental features have known limitations, and rather showcase some capabilities. Experimental features might even be removed in the future!</p> <ul> <li>EXPERIMENTAL: event exporter for Zeebe Simple Process Monitor </li> </ul>"},{"location":"advanced-microservice/","title":"Microservice & REST API","text":""},{"location":"advanced-microservice/#a-microservice-showcasing-a-fictionary-shopping-use-case","title":"A microservice, showcasing a fictionary shopping use case","text":"<p>The following example snippet shows how a microservice could use BPMN engine to process orders and provides status feedback to clients.</p> <p>For this example, we leverage messages and timers, to orchestrate some tasks. </p> <p>For this microservice, we first define some simple API.</p> <pre><code>package main\n\nimport \"net/http\"\n\nfunc initHttpRoutes() {\n    http.HandleFunc(\"/api/order\", handleOrder)                                        // POST new or GET existing Order\n    http.HandleFunc(\"/api/receive-payment\", handleReceivePayment)                     // webhook for the payment system\n    http.HandleFunc(\"/show-process.html\", handleShowProcess)                          // shows the BPMN diagram\n    http.HandleFunc(\"/index.html\", handleIndex)                                       // the index page\n    http.HandleFunc(\"/\", handleIndex)                                                 // the index page\n    http.HandleFunc(\"/ordering-items-workflow.bpmn\", handleOrderingItemsWorkflowBpmn) // the BPMN file, for documentation purpose\n}\n</code></pre> <p>Then we initialize the BPMN engine and register a trivial handler, which just prints on STDOUT.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n)\n\nfunc initBpmnEngine() {\n    bpmnEngine = bpmn_engine.New()\n    process, _ = bpmnEngine.LoadFromBytes(OrderingItemsWorkflowBpmn)\n    bpmnEngine.NewTaskHandler().Id(\"validate-order\").Handler(printHandler)\n    bpmnEngine.NewTaskHandler().Id(\"send-bill\").Handler(printHandler)\n    bpmnEngine.NewTaskHandler().Id(\"send-friendly-reminder\").Handler(printHandler)\n    bpmnEngine.NewTaskHandler().Id(\"update-accounting\").Handler(updateAccountingHandler)\n    bpmnEngine.NewTaskHandler().Id(\"package-and-deliver\").Handler(printHandler)\n    bpmnEngine.NewTaskHandler().Id(\"send-cancellation\").Handler(printHandler)\n}\n\nfunc printHandler(job bpmn_engine.ActivatedJob) {\n    // do important stuff here\n    println(fmt.Sprintf(\"%s &gt;&gt;&gt; Executing job '%s'\", time.Now(), job.ElementId()))\n    job.Complete()\n}\n\nfunc updateAccountingHandler(job bpmn_engine.ActivatedJob) {\n    println(fmt.Sprintf(\"%s &gt;&gt;&gt; Executing job '%s'\", time.Now(), job.ElementId()))\n    println(fmt.Sprintf(\"%s &gt;&gt;&gt; update ledger revenue account with amount=%s\", time.Now(), job.Variable(\"amount\")))\n    job.Complete()\n}\n</code></pre> <p>Since the <code>/api/order</code> endpoint can be requested with the GET or POST method, we need to make the handler smart enough to either create an order process instance or respond a status</p> <pre><code>package main\n\nimport (\n    _ \"embed\"\n    \"fmt\"\n    \"net/http\"\n    \"strconv\"\n)\n\nfunc handleOrder(writer http.ResponseWriter, request *http.Request) {\n    if request.Method == \"POST\" {\n        createNewOrder(writer, request)\n    } else if request.Method == \"GET\" {\n        showOrderStatus(writer, request)\n    }\n}\n\nfunc createNewOrder(writer http.ResponseWriter, request *http.Request) {\n    instance, _ := bpmnEngine.CreateAndRunInstance(process.ProcessKey, nil)\n    redirectUrl := fmt.Sprintf(\"/show-process.html?orderId=%d\", instance.GetInstanceKey())\n    http.Redirect(writer, request, redirectUrl, http.StatusFound)\n}\n\nfunc showOrderStatus(writer http.ResponseWriter, request *http.Request) {\n    orderIdStr := request.URL.Query()[\"orderId\"][0]\n    orderId, _ := strconv.ParseInt(orderIdStr, 10, 64)\n    instance := bpmnEngine.FindProcessInstance(orderId)\n    if instance != nil {\n        // we re-use this GET request to ensure we catch up the timers - ideally the service uses internal timers instead\n        bpmnEngine.RunOrContinueInstance(instance.GetInstanceKey())\n        bytes, _ := prepareJsonResponse(orderIdStr, instance.GetState(), instance.GetCreatedAt())\n        writer.Header().Set(\"Content-Type\", \"application/json\")\n        writer.Write(bytes)\n        return\n    }\n    http.NotFound(writer, request)\n}\n</code></pre> <p>Also, for the incoming payments, our microservice provides an endpoint so that we get informed by external payment service. This handler sends a message to the process instance and continues.</p> <pre><code>package main\n\nimport (\n    _ \"embed\"\n    \"net/http\"\n    \"strconv\"\n)\n\nfunc handleReceivePayment(writer http.ResponseWriter, request *http.Request) {\n    orderIdStr := request.FormValue(\"orderId\")\n    amount := request.FormValue(\"amount\")\n    if len(orderIdStr) &gt; 0 &amp;&amp; len(amount) &gt; 0 {\n        orderId, _ := strconv.ParseInt(orderIdStr, 10, 64)\n        processInstance := bpmnEngine.FindProcessInstance(orderId)\n        if processInstance != nil {\n            vars := map[string]interface{}{\n                \"amount\": amount,\n            }\n            bpmnEngine.PublishEventForInstance(processInstance.GetInstanceKey(), \"payment-received\", vars)\n            bpmnEngine.RunOrContinueInstance(processInstance.GetInstanceKey())\n            http.Redirect(writer, request, \"/\", http.StatusFound)\n            return\n        }\n    }\n    writer.WriteHeader(400)\n    writer.Write([]byte(\"Bad request: the request must contain form data with 'orderId' and 'amount', and the order must exist\"))\n}\n</code></pre> <p>To get the snippet compile, see the other sources in the examples/ordering_microservice/ folder.</p>"},{"location":"advanced-multiple-versions/","title":"Multiple BPMN process versions","text":""},{"location":"advanced-multiple-versions/#multiple-bpmn-process-versions","title":"Multiple BPMN process versions","text":"<p>The lib-bpmn-engine supports working with multiple version of a BPMN process. Typically, you want to do this, when you have long-running processes instances in-flight, and you want to e.g. bug-fix or improve a BPMN process. In such a scenario, you can't alter in-flight instances, but in parallel loading a newer v2 version, and create new instances from this v2 process. You could then decide to cancel older v1 process instances or simply wait for them to complete.</p>"},{"location":"advanced-multiple-versions/#hello-world-example-with-v1-and-v2","title":"Hello World example with v1 and v2","text":"<p>Consider you have two hello world processes ...</p> <p>v1 \\ </p> <p>v2 \\ </p> <p>Both definitions have the same ID=<code>hello-world-process-id</code>. The engine will load both and assign <code>version=2</code> to the second process. Creating new instances is then possible by either knowing the process key (which is returned when loading the BPMN), or by knowing the ID. The example below uses the latter.</p> <p>Hint: the handler will be called twice, since in v2, both service task have the same type.</p> <pre><code>package main\n\nimport (\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n)\n\nfunc main() {\n    // create a new named engine\n    bpmnEngine := bpmn_engine.New()\n    // basic example loading a v1 BPMN from file,\n    _, err := bpmnEngine.LoadFromFile(\"simple_task.bpmn\")\n    if err != nil {\n        panic(\"file \\\"simple_task.bpmn\\\" can't be read. \" + err.Error())\n    }\n    // now loading v2, basically with the same process ID\n    _, err = bpmnEngine.LoadFromFile(\"simple_task_v2.bpmn\")\n    if err != nil {\n        panic(\"file \\\"simple_task.bpmn\\\" can't be read. \" + err.Error())\n    }\n\n    // register a handler for a service task by defined task type\n    bpmnEngine.NewTaskHandler().Type(\"hello-world\").Handler(printElementIdHandler)\n    // and execute the process, means we will use v2\n    bpmnEngine.CreateAndRunInstanceById(\"hello-world-process-id\", nil)\n}\n\nfunc printElementIdHandler(job bpmn_engine.ActivatedJob) {\n    println(job.ElementId())\n    job.Complete() // don't forget this one, or job.Fail(\"foobar\")\n}\n</code></pre> <p>To get the snippet compile, see the full sources in the examples/timers/ folder.</p>"},{"location":"advanced-persistence/","title":"Persistence (marshalling)","text":""},{"location":"advanced-persistence/#persistence","title":"Persistence","text":"<p>The lib-bpmn-engine supports persistence (a.k.a. marshalling or serialization), which can be used to pause workflows, store them on disk and resume later. The data format is plain JSON, which you as the user of the lib must store and load. By design, the lib will not support any specific database technology.</p> <p>When calling <code>bpmnEngine.Marshal()</code>, the whole engine including all process instances is exported. When you have a large amount of process instances, it's recommended to rather use multiple engine instances, one per process instance, to keep the exported data small and efficient.</p>"},{"location":"advanced-persistence/#example","title":"Example","text":"<p>For this example, we're just using a simple human task, which is supposed to be stored on disk.</p> <p></p> <pre><code>package main\n\nimport \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n\nfunc main() {\n    bpmnEngine := bpmn_engine.New()\n    process, _ := bpmnEngine.LoadFromFile(\"simple-user-task.bpmn\")\n    bpmnEngine.NewTaskHandler().Assignee(\"assignee\").Handler(doNothingHandler())\n    instance, _ := bpmnEngine.CreateAndRunInstance(process.ProcessKey, nil)\n    instanceKey := instance.InstanceKey // remember the key for later continuation\n\n    // export the whole engine state as bytes\n    // the export format is valid JSON and can be stored however you want\n    bytes := bpmnEngine.Marshal()\n\n    // debug print ... in real-live the data is stored to disk/database\n    println(string(bytes))\n\n    resumeWorkflow(bytes, instanceKey)\n}\n\nfunc resumeWorkflow(bytes []byte, processInstanceKey int64) {\n    // import the bytes\n    newBpmnEngine, _ := bpmn_engine.Unmarshal(bytes)\n\n    // and resume the workflow for the give process instance key\n    _, _ = newBpmnEngine.RunOrContinueInstance(processInstanceKey)\n}\n\nfunc doNothingHandler() func(job bpmn_engine.ActivatedJob) {\n    return func(job bpmn_engine.ActivatedJob) {\n        println(\"Do nothing, which keeps the job active.\")\n        // HINT: to complete a job, the handler must call `job.Complete()`\n    }\n}\n</code></pre> <p>To get the snippet compile, see the full sources in the ./examples/persistence/ folder.</p>"},{"location":"advanced-timers/","title":"Timers & Schedulers","text":""},{"location":"advanced-timers/#timers","title":"Timers","text":"<p>The lib-bpmn-engine supports timer intermediate catch events, which are very useful to model typical timeout scenarios.</p> <p></p> <p>The one above \"ask $1 million question\" demonstrates a 10 seconds timeout to give the correct answer or lose the whole \"game\". This is a best-practice example, for how to model (business) timeouts or deadlines.</p>"},{"location":"advanced-timers/#how-to-model-timerscheduler","title":"How to model timer/scheduler?","text":"<p>In BPMN processes, Timer Intermediate Catch events can be used in combination with Event Based Gateway, to exclusively select one execution path in the process. When a timer event happens before a message event, then the example $1 million question game is lost. </p>"},{"location":"advanced-timers/#architectural-choices-for-timerscheduler","title":"Architectural choices for timer/scheduler","text":"<p>The Problem: implementing a timer/scheduler very much depends on your context or non-functional requirements. E.g. you might run lib-bpmn-engine as part of a single batch job instance OR you have a web service  implement which is running with 3 instances. Both scenarios do require different implementation approaches, how to deal with long-running processes.</p> <p>Choices: Depending on your scenario/use case, you might implement a trivial blocking loop, like in the example code below.  In multi-instance environments, you might better use a central scheduler, to avoid each instance of the application (using lib-bpmn-engine) is doing its own un-coordinated timing/scheduling.</p>"},{"location":"advanced-timers/#lib-bpmn-engine-design","title":"lib-bpmn-engine design","text":"<ul> <li>lib-bpmn-engine is not aware of how it's deployed</li> <li>lib-bpmn-engine will not block, when timers are set == this is like an implicit pause</li> <li>lib-bpmn-engine delegates scheduler/timer responsibility to the developer (==you)</li> </ul> <p>In a nutshell:  The lib-bpmn-engine does create such timer event objects and will pause the process execution. This means, an external ticker/scheduler is required, to continue the process instance.</p>"},{"location":"advanced-timers/#trivial-example-blocking-local-execution","title":"Trivial example, blocking local execution","text":"<p>The code snippet below demonstrates a trivial example, how to execute processes with timers. Here, the execution is blocking until the due time is reached. This might fit in a scenario, where you have a single instance running in a batch-job like environment.</p> <p>Depending on your context, you might choose some external ticker/scheduler, to check for active scheduled timer events.</p> <pre><code>package main\n\nimport (\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n    \"time\"\n)\n\nfunc main() {\n    bpmnEngine := bpmn_engine.New()\n    process, err := bpmnEngine.LoadFromFile(\"timeout-example.bpmn\")\n    if err != nil {\n        panic(\"file \\\"timeout-example.bpmn\\\" can't be read.\")\n    }\n    // just some dummy handler to complete the tasks/jobs\n    registerDummyTaskHandlers(&amp;bpmnEngine)\n\n    instance, err := bpmnEngine.CreateAndRunInstance(process.ProcessKey, nil)\n    println(instance.GetState()) // still ACTIVE at this point\n\n    printScheduledTimerInformation(bpmnEngine.GetTimersScheduled()[0])\n\n    // sleep() for 2 seconds, before trying to continue the process instance\n    // this for-loop essentially will block until the process instance has completed OR an error occurred\n    for ; instance.GetState() == bpmn_engine.Active &amp;&amp; err == nil; time.Sleep(2 * time.Second) {\n        println(\"tick.\")\n        // by re-running, the engine will check for active timers and might continue execution,\n        // if timer.DueAt has passed\n        _, err = bpmnEngine.RunOrContinueInstance(instance.GetInstanceKey())\n    }\n\n    println(instance.GetState()) // finally completed\n}\n</code></pre> <p>To get the snippet compile, see the full sources in the examples/timers/ folder.</p>"},{"location":"advanced-zeebe/","title":"Zeebe Exporter (visualization)","text":""},{"location":"advanced-zeebe/#visualize-process-state-via-zeebe-simple-monitor","title":"Visualize process state via Zeebe Simple Monitor","text":""},{"location":"advanced-zeebe/#overview","title":"Overview","text":"<p>Since lib-bpmn-engine runs embedded in your application, it's a challenge, to \"see what's happen inside\". Therefore, this library exports  all internal events and you can register various event exporters. That might be a simple STDOUT exporter, or one that exports to a dedicated visualisation application.</p> <p>There's an Open Source Web UI for monitoring BPMN processes Zeebe Simple Monitor. Fortunately, the authors did design the monitor as an event consumer. Thus, by exporting Zeebe compatible events, you're able to monitor your processes.</p>"},{"location":"advanced-zeebe/#screenshot","title":"Screenshot","text":""},{"location":"advanced-zeebe/#architecture","title":"Architecture","text":"<p>As shown in the architecture diagram, your App and Zeebe Simple Montor don't connect to each other, but rather your app needs to connect to a Hazelcast Ringbuffer. Once connected, the built-in Zeebe Exporter will export events to this Ringbuffer. The Zeebe Simple Monitor (ZSM) is a Java based application, which connects to the Ringbuffer as well and fetches events from there. Once fetched, ZSM stores events in it's own database. The ZSM database can be configured to your preferences.</p> <p>Please, keep in mind, this architecture does not support any namespacing. Means, when multiple of your applications connect to the same Ringbuffer, all events will be mixed up. That's less an issue technically, but might confuse your users.</p> <p></p>"},{"location":"advanced-zeebe/#limitations","title":"Limitations","text":"<p>As with the first and experimental release, just a handful of events are supported. This means, in contract to a full flavoured Zeebe cluster, events are missing and will not be shown. That said, basic functionality in Simple Monitor is given.</p> <p>Once you application restarts, workflows are newly deployed and so they are shown multiple times in Zeebe Simple Monitor (ZSM). This is because of the design/architecture of lib-bpmn-engine. With a new start of your app, a new ID will be assigned and ZSM ha no chance to detect former workflows/processes are identical.</p> <p>Housekeeping is missing in ZSM, which results in events just stack up and will slow down your database.</p> <p>The ringbuffer support in Hazelcast's Go client is not yet officially merged. So, lib-bpmn-engine uses a feature branch of the client to write to the ringbuffer.</p>"},{"location":"advanced-zeebe/#setup-for-tinkeringexperimenting","title":"Setup for tinkering/experimenting","text":"<p>Here are some hints, how you can quickly spin up a setup for experimenting. If you aim for a more production ready setup, please read&amp;learn how to do such with Hazelcast and Zeebe Simple Monitor on their official web sites individually.</p>"},{"location":"advanced-zeebe/#hazelcast","title":"Hazelcast","text":"<p>First, you need a running Hazelcast. The simplest way is using Docker... <pre><code>docker run -p 5701:5701  hazelcast/hazelcast:latest\n</code></pre></p>"},{"location":"advanced-zeebe/#zeebe-simple-monitor","title":"Zeebe Simple Monitor","text":"<p>Using Docker, also allows you to start a Zeebe Simple Monitor... <pre><code>docker run -p 8082:8082 -e \"zeebe.client.worker.hazelcast.connection=$(hostname):5701\" ghcr.io/camunda-community-hub/zeebe-simple-monitor:2.4.0```\n</code></pre></p> <p>\u26a0\ufe0f The above Docker containers do expose each service without any authentication! This mean, anyone in your network can connect to it - please, use a proper firewall or other tools to secure your system.</p>"},{"location":"advanced-zeebe/#zeebe-exporter-showcase-app","title":"Zeebe Exporter Showcase App","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/hazelcast/hazelcast-go-client\"\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine/exporter/zeebe\"\n)\n\nfunc main() {\n    // create a new named engine\n    bpmnEngine := bpmn_engine.New()\n    // the exporter will require a running Hazelcast cluster at 127.0.0.1:5701\n    ctx := context.TODO()\n    config := hazelcast.Config{}\n    config.Cluster.Network.SetAddresses(\"localhost:5701\")\n    client, err := hazelcast.StartNewClientWithConfig(ctx, config)\n    // create the client\n    exporter, _ := zeebe.NewExporterWithHazelcastClient(client)\n    // register the exporter\n    bpmnEngine.AddEventExporter(&amp;exporter)\n    // basic example loading a BPMN from file,\n    process, err := bpmnEngine.LoadFromFile(\"simple_task.bpmn\")\n    if err != nil {\n        panic(\"file \\\"simple_task.bpmn\\\" can't be read.\")\n    }\n    // register a handler for a service task by defined task type\n    bpmnEngine.NewTaskHandler().Id(\"hello-world\").Handler(printContextHandler)\n    // and execute the process\n    instance, _ := bpmnEngine.CreateAndRunInstance(process.ProcessKey, nil)\n\n    println(fmt.Sprintf(\"instanceKey=%d\", instance.GetInstanceKey()))\n}\n\nfunc printContextHandler(job bpmn_engine.ActivatedJob) {\n    // trivial handler is requires\n    job.Complete()\n}\n</code></pre>"},{"location":"expression-syntax/","title":"Expression Syntax","text":""},{"location":"expression-syntax/#expression-syntax","title":"Expression Syntax","text":"<p>Cite from the BPMN 2.0 specification... BPMN does not itself provide a built-in model for describing structure of data or an Expression language for querying that data. Instead, it formalizes hooks that allow for externally defined data structures and Expression languages.</p> <p>This lib-bpmn-engine uses the FEEL - Friendly Enough Expression Language for evaluating expressions. FEEL is part of the Decision Modeling Notation (DMN) and commonly used by BPMN engines.</p>"},{"location":"expression-syntax/#expression-in-exclusive-gateways","title":"Expression in exclusive gateways","text":"<p>Expressions used in exclusive gateways must evaluate to a single boolean value. The lib-bpmn-engine adheres to FEEL standards, which means expressions are simply writen such as <code>price &gt; 10</code>. Hint: other engines allow expressions to start with <code>=</code> (equal sign) which, as said is not the case here.</p>"},{"location":"expression-syntax/#variables","title":"Variables","text":"<p>Variables can be provided to the engine, when a task is executed. The library is type aware. E.g. in the examples below (boolean expressions), <code>owner</code> must of type string and <code>totalPrice</code> of type int or float.</p>"},{"location":"expression-syntax/#boolean-expressions","title":"Boolean expressions","text":"Operator Description Example = (just one equals sign) equal to owner = \"Paul\" != not equal to owner != \"Paul\" &lt; less than totalPrice &lt; 25 &lt;= less than or equal to totalPrice &lt;= 25 &gt; greater than totalPrice &gt; 25 &gt;= greater than or equal to totalPrice &gt;= 25"},{"location":"expression-syntax/#mathematical-expressions","title":"Mathematical expressions","text":"<p>Basic mathematical operations are supported and can be used in conditional expressions. E.g. if you define these variables and provide them to the context of a process instance, then the expression <code>sum &gt;= foo + bar</code> will evaluate to <code>true</code>. <pre><code>    variables := map[string]interface{}{\n        \"foo\": 3,\n        \"bar\": 7,\n        \"sum\": 10,\n    }\n    bpmnEngine.CreateAndRunInstance(key, variables)\n</code></pre></p>"},{"location":"expression-syntax/#supported-data-types","title":"Supported data types","text":"<p>The package supports:</p> <ul> <li>Numbers - e.g. <code>103</code>, <code>2.5</code></li> <li>Strings - e.g. <code>\"hello\"</code></li> <li>Boolean - <code>true</code> and <code>false</code></li> <li>Dates</li> <li>Time</li> <li>DateTime</li> <li>Days and time duration</li> <li>Years and months duration</li> <li>Ranges (or intervals)</li> <li>Lists - e.g. <code>[1, 2, 3]</code></li> </ul>"},{"location":"expression-syntax/#supported-operators","title":"Supported Operators","text":"<p>The package comes with a lot of operators:</p>"},{"location":"expression-syntax/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code> (addition)</li> <li><code>-</code> (subtraction)</li> <li><code>*</code> (multiplication)</li> <li><code>/</code> (division)</li> <li><code>%</code> (modulus)</li> <li><code>**</code> (pow)</li> </ul> <p>Example:</p> <pre><code>life + 42 // assuming life is of type number as well\n</code></pre>"},{"location":"expression-syntax/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>=</code> (equal)</li> <li><code>!=</code> (not equal)</li> <li><code>&lt;</code> (less than)</li> <li><code>&gt;</code> (greater than)</li> <li><code>&lt;=</code> (less than or equal to)</li> <li><code>&gt;=</code> (greater than or equal to)</li> </ul>"},{"location":"expression-syntax/#builtin-string-functions","title":"Builtin string functions","text":"<ul> <li><code>\"foo\" + \"bar\"</code> -&gt; result: \"foobar\"</li> <li><code>string length(\u201cfoobar\u201d)</code> -&gt; result: 23</li> <li><code>upper case(\u201cfoobar\u201d)</code> -&gt; result: \u201cFOOBAR\u201d</li> <li><code>lower case(\u201cFOOBAR\u201d)</code> -&gt; result: \u201cfoobar\u201d</li> <li><code>substring(\u201cfoobar\u201d, 2, 2)</code> -&gt; result: \u201coo\u201d</li> <li><code>contains(\u201cfoobar\u201d, \u201cfoo\u201d)</code> -&gt; result: true</li> <li><code>contains(\u201cfoobar\u201d, \u201c???\u201d)</code> -&gt; result: false</li> <li><code>starts with (\"foobar\", \"foo\")</code> -&gt; result: true</li> <li><code>ends with (\"foobar\", \"bar\")</code> -&gt; result: true</li> <li><code>string join([\"foo\",\"bar\"], \"-\")</code> -&gt; result: \"foo-bar\"</li> <li><code>string join([\"foo\",\"bar\"])</code> -&gt; result: \"foobar\"</li> </ul>"},{"location":"expression-syntax/#ternary-operators","title":"Ternary Operators","text":"<p>There is no operator but rather expression support, like so...</p> <ul> <li><code>if true then \u201cYES\u201d else \u201cNO\u201d</code></li> </ul> <p>Example:</p> <pre><code>if user.Age &gt; 30 then \"mature\" else \"immature\"\n</code></pre>"},{"location":"expression-syntax/#logical-operators","title":"Logical Operators","text":"<ul> <li><code>not</code></li> </ul> <p>Example:</p> <pre><code>not (true)\nnot (price &gt; 20)\n</code></pre>"},{"location":"expression-syntax/#accessing-structs-public-properties","title":"Accessing structs (public properties)","text":"<p>Expression language can be used to access public properties in structs. Given a <code>TestItem</code>, provided before the process instance runs, via variables...</p> <pre><code>    type TestItem struct {\n        Key string\n    }\n    scope := Scope{\n        \"data\": TestItem{Key: \"foobar\"},\n    }\n</code></pre> <p>... then the following expression can be used to retrieve values from the struct:</p> <pre><code>get value( data, \"Key\" ) // returns \"foobar\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Here are two example on how to use the library.</p>"},{"location":"getting-started/#hello-world-example","title":"Hello World Example","text":"<p>Assuming this simple 'Hello World' BPMN example should just print \"hello world\". \\ </p> <p>Then a simple (and verbose) code to execute this looks like this</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n)\n\nfunc main() {\n    // create a new named engine\n    bpmnEngine := bpmn_engine.New()\n    // basic example loading a BPMN from file,\n    process, err := bpmnEngine.LoadFromFile(\"simple_task.bpmn\")\n    if err != nil {\n        panic(\"file \\\"simple_task.bpmn\\\" can't be read.\")\n    }\n    // register a handler for a service task by defined task id (there are alternative options for types as well)\n    bpmnEngine.NewTaskHandler().Id(\"hello-world\").Handler(printContextHandler)\n    // setup some variables\n    variables := map[string]interface{}{}\n    variables[\"foo\"] = \"bar\"\n    // and execute the process\n    bpmnEngine.CreateAndRunInstance(process.ProcessKey, variables)\n}\n\nfunc printContextHandler(job bpmn_engine.ActivatedJob) {\n    println(\"&lt; Hello World &gt;\")\n    println(fmt.Sprintf(\"ElementId                = %s\", job.ElementId()))\n    println(fmt.Sprintf(\"BpmnProcessId            = %s\", job.BpmnProcessId()))\n    println(fmt.Sprintf(\"ProcessDefinitionKey     = %d\", job.ProcessDefinitionKey()))\n    println(fmt.Sprintf(\"ProcessDefinitionVersion = %d\", job.ProcessDefinitionVersion()))\n    println(fmt.Sprintf(\"CreatedAt                = %s\", job.CreatedAt()))\n    println(fmt.Sprintf(\"Variable 'foo'           = %s\", job.Variable(\"foo\")))\n    job.Complete() // don't forget this one, or job.Fail(\"foobar\")\n}\n</code></pre>"},{"location":"implementation-ids/","title":"IDs (process IDs)","text":""},{"location":"implementation-ids/#ids-process-definition-process-instance-job-events-etc","title":"IDs (process definition, process instance, job, events, etc.)","text":"<p>This engine does use an implementation of Twitter's Snowflake algorithm which combines some advantages, like it's time based and can be sorted, and it's collision free to a very large extend. So you can rely on larger IDs were generated later in time, and they will not collide with IDs, generated on e.g. other nodes of your application in a multi-node installation.</p> <p>The IDs are structured like this ... <pre><code>+-----------------------------------------------------------+\n| 41 Bit Timestamp |  10 Bit NodeID  |   12 Bit Sequence ID |\n+-----------------------------------------------------------+\n</code></pre></p> <p>The NodeID is generated out of a hash-function which reads all environment variables. As a result, this approach allows 4096 unique IDs per node and per millisecond.</p>"},{"location":"implementation-task-handlers/","title":"Task Handlers","text":""},{"location":"implementation-task-handlers/#task-handlers","title":"Task Handlers","text":""},{"location":"implementation-task-handlers/#declaration-definition","title":"Declaration &amp; Definition","text":"<p>You can declare service tasks and users tasks in BPMN. Both declarations have in common, that you must specify a unique ID per task element. Per each ID, you can add/define a single task handler, when using the engine.</p> <p>For some use cases you might want to add/define a single task handler for multiple tasks. This is, where the task 'type' comes into play. This library is compatible with Zeebe's 'taskDefinition' extension, which allows you to declare a single 'type' for many tasks in the BPMN, and thus you're able to use just a single handle for this type. For user tasks you can define an 'assignee' or multiple 'candidate groups' as in Zeebe.</p> <p>In case multiple handlers are defined and would potentially match the declaration, the specific ones have precedence over the generic ones. Also, first defined one wins. For service tasks this means, the handler with ID matching is called instead of the handler with TYPE matching. And for user tasks this means, the handler with ID matching is called instead of the handler with assignee matching instead of the handler with a candidate group matching.</p> <p>\u2139\ufe0f In contrast to Zeebe, the declarations for 'type', 'assignee', and 'candidateGroups' are not evaluated but just treated as static string constants in lib-bpmn-engine.</p>"},{"location":"implementation-task-handlers/#service-tasks-vs-user-tasks","title":"Service Tasks vs. User Tasks","text":"<p>The engine (as of now) handles service tasks and user tasks almost equal. There are some differences you should consider, when implementing your handler(s).</p> <ul> <li>add/register handlers for 'id' os possible for all tasks</li> <li>add/register a handler for 'type' is only possible for service tasks</li> <li>add/register a handler for 'assignee' or 'candidate groups' is only possible for user tasks</li> <li>tasks can be paused<ul> <li>a task handler must always call <code>.Complete()</code> or <code>.Fail()</code>, when work is completed</li> <li>a task handler might just return (without calling <code>.Complete()</code> or <code>.Fail()</code>), and being resumed later in time (see below)</li> </ul> </li> </ul>"},{"location":"implementation-task-handlers/#synchronous-vs-asynchronous","title":"Synchronous vs. Asynchronous","text":"<p>By default, the lib-bpmn-engine expects a task handler to complete a task, by calling the <code>.Complete()</code> or <code>.Fail()</code> function. So, when you're implementing with this library, your task handlers would be called synchronously. But, when task handlers do e.g. check external DB for a parcel delivery in a certain state, and then simply return, without signaling complete or fail, then you can implement asynchronous behaviour. This also mean, you need to call <code>.RunOrContinueInstance()</code> until your process instance reaches the <code>Completed</code> state. See also the example in section Pause and resume tasks</p>"},{"location":"implementation-task-handlers/#pause-and-resume-tasks","title":"Pause and resume Tasks","text":"<p>Hint: this section is more tailored for user tasks, but works likewise for service tasks.</p> <p>Processing a simple user task typically involves external action by a human. The lib-bpmn-engine will therefore pause a process instance, when such a task is reached.</p> <p></p> <p>The example code mimics the external action via the <code>externalEvent</code> variable. Typically, you will create and run an instance, then notify a human and once the human responses with some event, you will continue the process. The <code>.Complete()</code> and <code>.Fail()</code> methods let you handle errors.</p> <pre><code>package main\n\nimport (\n    \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\"\n)\n\nfunc main() {\n    bpmnEngine := bpmn_engine.New()\n    process, _ := bpmnEngine.LoadFromFile(\"simple-user-task.bpmn\")\n    bpmnEngine.NewTaskHandler().Assignee(\"assignee\").Handler(userTaskHandler())\n    instance, _ := bpmnEngine.CreateAndRunInstance(process.ProcessKey, nil)\n    // ... just wait for the human completed his/her task\n    bpmnEngine.RunOrContinueInstance(instance.GetInstanceKey())\n}\n\nvar externalEvent = \"none\"\n\nfunc userTaskHandler() func(job bpmn_engine.ActivatedJob) {\n    return func(job bpmn_engine.ActivatedJob) {\n        if externalEvent == \"none\" {\n            // send notification to user\n        }\n        if externalEvent == \"user is done\" {\n            job.Complete()\n        }\n        if externalEvent == \"user is done but wrong response\" {\n            job.Fail(\"error in user task\")\n        }\n        // just return and so 'pause' the process instance\n    }\n}\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":"<p>This is an overview of the roadmap. The project is managed on Github's lib-bpmn-engine milestones page.</p>"},{"location":"roadmap/#v010","title":"\u2705 v0.1.0","text":"<p>progress milestone v0.1.0</p> <p>For the first release I would like to have service tasks and events fully supported.</p>"},{"location":"roadmap/#v020","title":"\u2705 v0.2.0","text":"<p>progress milestone v0.2.0</p> <p>With basic element support, I would like to add visualization/monitoring capabilities. If the idea of using Zeebe's exporter protocol is not too complex, that would be ideal. If not, a simple console logger might do the job as well. Also, I would like to add expression language support as well as support for correlation keys</p>"},{"location":"roadmap/#v030","title":"\u2699\ufe0f v0.3.0","text":"<p>progress milestone v0.3.0</p> <p>One last but very important feature I aim for is the ability to load &amp; store state. Which means, that you as app developer would be able to persistent in-flight process instances for later restoring and completion.</p> <p>Another big step will be the support for the FEEL language, and the ability to save/load state of the engine</p>"},{"location":"roadmap/#v00","title":"\ud83d\udd2e\ufe0f v0.?.0","text":"<p>\ud83e\udd14more elements to be supported ... or more events to be exported</p>"},{"location":"supported-elements/","title":"Supported Elements","text":"<p>These BPMN elements are supported by the latest release of lib-bpmn-engine. There are some comments as well, which describe the level of support per each element.</p>"},{"location":"supported-elements/#start-event","title":"Start Event","text":"<ul> <li>multiple start events are supported and are triggered in order of appearance. </li> </ul>"},{"location":"supported-elements/#end-event","title":"End Event","text":"<ul> <li>multiple end events are supported as well.</li> </ul>"},{"location":"supported-elements/#service-task","title":"Service Task","text":"<ul> <li>you can define task handlers for one or multiple tasks (by ID or by Type)</li> <li>get &amp; set variables from/to context (of the instance) is possible</li> <li>variable mapping is supported (for input and output, see Variables)</li> </ul>"},{"location":"supported-elements/#user-task","title":"User Task","text":"<ul> <li>you can define task handlers for one or multiple tasks (by assignee or by candidate groups)</li> <li>equally handled like service tasks</li> <li>get &amp; set variables from/to context (of the instance) is possible</li> <li>variable mapping is supported (for input and output, see Variables)</li> </ul>"},{"location":"supported-elements/#sub-process","title":"Sub Process","text":"<ul> <li>sub-processes can encapsulate a series of tasks and events.</li> <li>supports both embedded and reusable sub-processes.</li> <li>allows for better organization and modularization of complex workflows.</li> <li>sub-processes can have their own start and end events.</li> <li>supports variable mapping for input and output, similar to tasks.</li> <li>can be used to handle repetitive or complex logic within a process.</li> </ul>"},{"location":"supported-elements/#gateways","title":"Gateways","text":"<p>The Parallel Gateway and the Exclusive Gateway do allow fork and join logic, as well as parallel execution. The library does not support real parallel execution, but flows are processed in order of appearance in the BPMN file.</p> <ul> <li>Forks<ul> <li>controlled and uncontrolled forks are supported</li> <li>parallel gateway supported</li> <li>exclusive gateway with conditions supported</li> </ul> </li> <li>Joins<ul> <li>uncontrolled and exclusive joins are supported</li> <li>parallel joins are supported</li> </ul> </li> </ul>"},{"location":"supported-elements/#exclusive-gateway","title":"Exclusive Gateway","text":"<ul> <li>fully supported, incl. conditional expressions per each outgoing flow</li> </ul>"},{"location":"supported-elements/#inclusive-gateway","title":"Inclusive Gateway","text":"<ul> <li>fully supported, incl. conditional expressions per each outgoing flow</li> </ul>"},{"location":"supported-elements/#parallel-gateway","title":"Parallel Gateway","text":"<ul> <li>fully supported, incl. conditional expressions per each outgoing flow</li> </ul>"},{"location":"supported-elements/#event-based-gateway","title":"Event Based Gateway","text":"<ul> <li>fully supported</li> </ul>"},{"location":"supported-elements/#message-intermediate-catch-event","title":"Message Intermediate Catch Event","text":"<ul> <li>at the moment, just matching/correlation by name supported</li> <li>variable mapping is supported (for output, see Variables)</li> </ul>"},{"location":"supported-elements/#timer-intermediate-catch-event","title":"Timer Intermediate Catch Event","text":"<ul> <li>supported</li> <li>a ticker/scheduler needs to be externally provided, see Timers</li> </ul>"},{"location":"supported-elements/#link-intermediate-throw-catch-event","title":"Link Intermediate Throw &amp; Catch Event","text":"<ul> <li>supported</li> <li>variable mapping is supported(for output, see Variables)</li> </ul>"},{"location":"supported-elements/#variables","title":"Variables","text":""},{"location":"supported-elements/#input-variables","title":"Input Variables","text":"<p>Input mappings can be used to create new variables. They can be defined on service tasks and user task. When an input mapping is applied, it creates a new local variable in the scope (visible in the task handler) where the mapping is defined.</p>"},{"location":"supported-elements/#output-variables","title":"Output Variables","text":"<p>Output mappings can be used to customize how job/message variables are merged into the process instance. They can be defined on service tasks, user tasks, and message catch events.</p> <p>Within a task handler, variables are set as local variables (local scope). When the handler completes the job, the output mappings are applied to the variables and create new variables in this scope. The new variables are merged into the parent scope (typically the process instance). If there is no mapping for a job/message variable, the variable is not merged. In other words: if one or more variables are defined, only these are mapped.</p> <p>If no output mappings are defined, all job/message variables are merged into the process instance.</p>"}]}